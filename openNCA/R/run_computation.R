#' Run Computation 
#'
#' This function gets the terminal or elimination phase rate constant, which is described as the absolute
#' value of the slope of a least-squares linear regression during the terminal phase of the natural-logarithm
#' (ln) transformed concentration-time profile.
#' 
#' @aliases kel_tmlo kel_tmhi kel_nopt
#' 
#' @details
#' \strong{First calculate slope} \cr  
#' \figure{kel_eq1.png} \cr
#' \figure{kel_eq2.png} \cr
#' \figure{kel_eq3.png} \cr
#' \eqn{S = Slope} \cr
#' \eqn{C_{i} = i^{th} concentration}{Ci = ith concentration} \cr
#' \eqn{T_{i} = i^{th} time}{Ti = ith time} \cr
#' \eqn{n = the number of data points} \cr \cr
#' \strong{Terminal log-linear phase} = The phase in the natural-log transformed concentration-time profile selected
#' by user at the time of primary parameter computaitons via interactive concentration-time plots(refer to KEL
#' tab on the front end) \cr \cr  
#' Set time of last dose TDOSE to 0 and shift T accordingly in calculation of KEL. This impacts the C0 the intercept
#' used in other paramerter calculations AUCINF \cr \cr
#' \strong{Equation for KEL}\cr \eqn{KEL = S x -1} \cr
#' 
#' @section Note:
#' If concentrations are less than or equal to zero or 'NA' for a data point, that data point is not used
#' in calculations. There needs to be atleast 2 data points in the data. If KEL is less than 0 then the function
#' will return 'ND' for Not Determined. And also you must provide a valid sid with respect to the data. 
#' 
#' @param data The model data that was generated by \code{\link{model}} 
#' @param sid The subject ID (either can be the id number or 'all' to get kel for all the subjects)
#' @section Returns:
#' \strong{Dataset} \cr 
#' \itemize{
#'  \item SID: subject identification number
#'  \item KEL: maximum observed concentration
#'  \item TMLO: intial timepoint used in the calculation of KEL
#'  \item TMHI: final timepoint used in the calculation of KEL
#'  \item NOPT: number of time points used in the calculation of KEL
#' }
#' @section Additional Details:
#' If KEL returns 'ND' or 'Not Determined' then TMHI and TMLO both are set to 'ND' as well. If TMLO is greater
#' than or equal to TMHI, then TMLO is set to 'ND. If TMHI is less than or equal to TMLO, then TMHI is set
#' to 'ND'.
#' @examples 
#' ##########
#' ## Data ##
#' #################################
#' ##  SID  ##  TIME  ##  RESULT  ##
#' #################################
#' ##   30  ##    0   ##   2.89   ##
#' ##   30  ##    1   ##   2.49   ##
#' ##   30  ##    2   ##   2.47   ##
#' ##   31  ##    0   ##      0   ##
#' ##   31  ##    1   ##   1.00   ##
#' ##   31  ##    2   ##      0   ##
#' ##   32  ##    0   ##   1.19   ##
#' ##   32  ##    1   ##   1.23   ##
#' ##   32  ##    2   ##   1.34   ##
#' ##   32  ##    4   ##   1.32   ##
#' #################################
#' 
#' data <- data.frame(
#'     SID = ...,
#'     TIME = ...,
#'     RESULT = ...
#' )
#' #Same data as above, just represented as a dataframe
#' 
#' kel()   
#' #No data found!
#' 
#' kel(data)  
#' #Object not of class NCA
#' 
#' mod <- model("~/data.csv")  
#' #Creates an NCA object with data represented in 'data' above
#' kel(mod)  
#' #Please specify for which subject you want to get the KEL for!
#' 
#' kel(mod, sid = "all")  
#' # SID     KEL TMLO  TMHI  NOPT
#' #  30  0.0785    0     2     3
#' #  31      ND   ND    ND     1
#' #  32      ND   ND    ND     4
#' 
#' kel(mod, sid = 31)  
#' # SID KEL TMLO TMHI NOPT
#' #  31  ND  ND    ND   1
#' 
#' kel(mod, sid = 10)  
#' #Invaild subject ID! Subject ID not found in the data provided!
#' 
#' @author
#' \itemize{
#'  \item Kevin McConnell
#' }
#' @export
run_computation <- function(data = NULL, map = NULL, return = list()){
  if(is.null(data)){
    stop("Please provide a valid path for the 'data' parameter")
  } else {
    if(is.data.frame(data)){
      data_data <- data
    } else {
      if(file.exists(data)){
        data_data <- read.csv(file = data)
      } else {
        stop("Invalid path provided for 'data'! Please provide a valid path for the 'data' parameter")
      } 
    }
  }
  if(is.null(map)){
    stop("Please provide a valid path for the 'map' parameter")
  } else {
    if(is.data.frame(map)){
      map_data <- as.data.frame(lapply(map, as.character), stringsAsFactors = FALSE)
    } else {
      if(file.exists(map)){
        map_data <- read.csv(file = map, stringsAsFactors = FALSE)
      } else {
        stop("Invalid path provided for 'map'! Please provide a valid path for the 'map' parameter")
      }
    }
  }
  if(!("SDEID" %in% names(map_data) && "NOMTIME" %in% names(map_data) && "CONC" %in% names(map_data))){
    stop("Dataset provided via 'map' does not contain the required columns")
  }
  if(!(map_data$SDEID %in% names(data_data) && map_data$NOMTIME %in% names(data_data) && map_data$CONC %in% names(data_data))){
    stop("Values provided via 'map' are not present in the dataset provided via 'data'")
  }
  
  computation_list <- list("cmax", "cmin", "clast", "tmax", "tmin", "tlast", "kel", "kelr")

  if(tolower(return) == 'all' ||  (typeof(return) == 'list' && length(return) == 0)){
    computation_df <- data.frame(matrix(ncol = 14, nrow = 0)) 
    names(computation_df) <- c("SDEID", "CMAX", "CMIN", "CLAST", "TMAX", "TMIN", "TLAST", "KEL", "KELTMLO", "KELTHMI", "KELNOPT", "KELR", "KELRSQ", "KELSQADJ")
    
    cmax_df <- cmax_i(data, map)
    cmin_df <- cmin_i(data, map)
    clast_df <- clast_i(data, map)
    tmax_df <- tmax_i(data, map)
    tmin_df <- tmin_i(data, map)
    tlast_df <- tlast(data, map)
    kel_df <- kel(data, map)
    kelr_df <- kel_rsq(data, map)
    
    for(i in 1:length(unique(data_data[,map_data$SDEID]))){
      computation_df[i,] <- c(unique(data_data[,map_data$SDEID])[i], cmax_df$CMAX[i], cmin_df$CMIN[i], clast_df$CLAST[i], tmax_df$TMAX[i], tmin_df$TMIN[i], tlast_df$TLAST[i], 
                             kel_df$KEL[i], kel_df$KELTMLO[i], kel_df$KELTHMI[i], kel_df$KELNOPT[i], kelr_df$KELR[i], kelr_df$KELRSQ[i], kelr_df$KELSQADJ[i])
    }
  } else {
    if(typeof(return) == "list" && !any(!return %in% computation_list)) {
      count <- 1
      col_names <- c("SDEID")
      
      if("cmax" %in% return){
        count <- count + 1
        col_names[count] <- "CMAX"
        cmax_df <- cmax_i(data, map)
      }
      if("cmin" %in% return){
        count <- count + 1
        col_names[count] <- "CMIN"
        cmin_df <- cmin_i(data, map)
      }
      if("clast" %in% return){
        count <- count + 1
        col_names[count] <- "CLAST"
        clast_df <- clast_i(data, map)
      }
      if("tmax" %in% return){
        count <- count + 1
        col_names[count] <- "TMAX"
        tmax_df <- tmax_i(data, map)
      }
      if("tmin" %in% return){
        count <- count + 1
        col_names[count] <- "TMIN"
        tmin_df <- tmin_i(data, map)
      }
      if("tlast" %in% return){
        count <- count + 1
        col_names[count] <- "TLAST"
        tlast_df <- tlast(data, map)
      }
      if("kel" %in% return){
        col_names[count+1] <- "KEL"
        col_names[count+2] <- "KELTMLO"
        col_names[count+3] <- "KELTMHI"
        col_names[count+4] <- "KELNOPT"
        count <- count + 4
        kel_df <- kel(data, map)
      }
      if("kelr" %in% return){
        col_names[count+1] <- "KELR"
        col_names[count+2] <- "KELRSQ"
        col_names[count+3] <- "KELRSQADJ"
        count <- count + 3
        kelr_df <- kel_rsq(data, map)
      }
      
      computation_df <- data.frame(matrix(ncol = count, nrow = 0)) 
      names(computation_df) <- col_names
      
      for(i in 1:length(unique(data_data[,map_data$SDEID]))){
        row_data <- c(unique(data_data[,map_data$SDEID])[i])
        if("cmax" %in% return){
          row_data <- append(row_data, cmax_df$CMAX[i], length(row_data))
        }
        if("cmin" %in% return){
          row_data <- append(row_data, cmin_df$CMIN[i], length(row_data))
        }
        if("clast" %in% return){
          row_data <- append(row_data, clast_df$CLAST[i], length(row_data))
        }
        if("tmax" %in% return){
          row_data <- append(row_data, tmax_df$TMAX[i], length(row_data))
        }
        if("tmin" %in% return){
          row_data <- append(row_data, tmin_df$TMIN[i], length(row_data))
        }
        if("tlast" %in% return){
          row_data <- append(row_data, tlast_df$TLAST[i], length(row_data))
        }
        if("kel" %in% return){
          row_data <- append(row_data, kel_df$KEL[i], length(row_data))
          row_data <- append(row_data, kel_df$KELTMLO[i], length(row_data))
          row_data <- append(row_data, kel_df$KELTHMI[i], length(row_data))
          row_data <- append(row_data, kel_df$KELNOPT[i], length(row_data))
        }
        if("kelr" %in% return){
          row_data <- append(row_data, kelr_df$KELR[i], length(row_data))
          row_data <- append(row_data, kelr_df$KELRSQ[i], length(row_data))
          row_data <- append(row_data, kelr_df$KELSQADJ[i], length(row_data))
        }
        
        computation_df[i,] <- row_data
      }
    } else {
      stop("Values provided via 'return' are not valid or cannot be calculated! Please provide valid inputs")
    }
  }
  
  return(computation_df)
}

